# Event Store Implementation

To implement Event Store interface as requested, first we need to find a data structure that helps to meet the requirements of being
fast, memory-efficient, and thread-safe and also have in mind that insertions, deletions, queries, and iterations will happen frequently and concurrently.

### Thread-safe requirement
The natural choice would be a thread safe collection to store the event objects. 
Discarding the old legacies java 1.0 collection implementations from java.util package as Stack, Vector and Hashtable, we can make use of the following method to turn a collection thread safe.

```java
Collections.synchronizedList(new ArrayList<Event>())
```
There are variations for other kind of collections like Set and Map. Unfortunately these methods creates a wrapper (decorator) over the original collection. This wrapper keeps a mutex locks the entire collection before each operation (object-level synchronization). Also iterators are still not synchronized we need to manually synchronize them. There is a penalty in performance, as only one single thread can access the collection at a time. We must choose a collection from the java.util.concurrent package, which are much more performant. Potential candidates are:

* CopyOnWriteArrayList
* ConcurrentLinkedQueue
* ConcurrentHashMap (I don't think it fits nicely because we have to map keys to type event and store a list of event, being necessary other collection)

### Memory Efficient requirement

CopyOnWriteArrayList is very fast for reading but has a huge overhead in adding and removing elements replacing the whole list on write operation.
This can cause memory issues.

### Fast

ConcurrentLinkedQueue is fast, not as fast like CopyOnWriteArrayList in queries and iterations, but has an really acceptable performance.
It does not have the memory issues and overhead in insertions and deletions like CopyOnWriteArrayList.
ConcurrentLinkedQueue is a queue backed by a linked list. So insertions are O(1) and other operations are O(n).

This implementation employs an efficient "wait-free" algorithm based on one described in Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms by Maged M. Michael and Michael L. Scott.

### Design Choices

I've decided create a class EventStoreImpl with really simple methods to insert, removeAll and querying.
The query method returns a EventIterator, so i've decided to use an Iterator from the backend collection (ConcurrentLinkedQueue) generated by a filtered (query conditions) stream from this collection. So the EventIteratorImpl is an adapter to this iterator turning the implementation very easy. Unfortunately the remove method from the original iterator throws an UnsupportedOperationException so we have to use the remove method from the backend collection. Since the EventIteratorImpl needs a reference to the backend collection in order to implement the remove method, i've decided to turn this class into a private inner class since an iterator has a strong coupling with your DataSource. I was not concerned with defensive code, so i did not implemented any validations like checking passing nulls, i believe this is not a case since is not a production implementation.

### Tests

There is 15 tests that tests varios scenarios ranging from querying to insertion and deletion and also concurrency scenarios.  


